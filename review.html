<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sublobe Pattern Review</title>
    <style>
        * { box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            color: #4a9;
            margin-bottom: 10px;
        }
        
        .instructions {
            text-align: center;
            color: #888;
            margin-bottom: 20px;
            font-size: 14px;
        }
        
        .instructions code {
            background: #222;
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        /* Stats bar */
        .stats {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #1a1a1a;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333;
            z-index: 100;
        }
        
        .stats .counts span {
            margin-right: 20px;
        }
        
        .stats .liked { color: #4a9; }
        .stats .disliked { color: #a44; }
        .stats .pending { color: #aa4; }
        
        .stats button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 10px;
        }
        
        .stats .export-btn { background: #4a9; color: #000; }
        .stats .reset-btn { background: #444; color: #fff; }
        .stats .filter-btn { background: #333; color: #fff; border: 1px solid #555; }
        .stats .filter-btn.active { background: #4a9; color: #000; border-color: #4a9; }
        
        /* Gallery grid */
        .gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 20px;
            margin-top: 70px;
            padding-bottom: 40px;
        }
        
        /* Card */
        .card {
            background: #1a1a1a;
            border-radius: 12px;
            overflow: hidden;
            transition: transform 0.2s, box-shadow 0.2s;
            border: 2px solid transparent;
        }
        
        .card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
        }
        
        .card.liked { border-color: #4a9; }
        .card.disliked { border-color: #a44; opacity: 0.5; }
        .card.disliked:hover { opacity: 1; }
        
        .card img {
            width: 100%;
            height: 280px;
            object-fit: contain;
            background: #111;
            cursor: pointer;
        }
        
        .card .info {
            padding: 12px;
        }
        
        .card .uuid {
            font-family: monospace;
            font-size: 12px;
            color: #666;
        }
        
        .card .meta {
            font-size: 13px;
            color: #888;
            margin-top: 4px;
        }
        
        .card .actions {
            display: flex;
            gap: 10px;
            padding: 12px;
            background: #111;
        }
        
        .card .actions button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: background 0.2s;
        }
        
        .card .actions .like-btn {
            background: #1a3a2a;
            color: #4a9;
        }
        .card .actions .like-btn:hover { background: #2a5a3a; }
        .card .actions .like-btn.active { background: #4a9; color: #000; }
        
        .card .actions .dislike-btn {
            background: #3a1a1a;
            color: #a44;
        }
        .card .actions .dislike-btn:hover { background: #5a2a2a; }
        .card .actions .dislike-btn.active { background: #a44; color: #fff; }
        
        /* Hidden cards */
        .card.hidden { display: none; }
        
        /* Lightbox */
        .lightbox {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 200;
            justify-content: center;
            align-items: center;
        }
        
        .lightbox.active { display: flex; }
        
        .lightbox img {
            max-width: 90vw;
            max-height: 90vh;
            object-fit: contain;
        }
        
        .lightbox .close {
            position: absolute;
            top: 20px;
            right: 30px;
            font-size: 40px;
            color: #fff;
            cursor: pointer;
        }
        
        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 60px;
            color: #666;
        }
        
        .empty-state h2 { color: #888; }
        
        /* Keyboard hints */
        .keyboard-hints {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: #222;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            color: #666;
        }
        
        .keyboard-hints kbd {
            background: #333;
            padding: 2px 6px;
            border-radius: 3px;
            margin: 0 4px;
        }
    </style>
</head>
<body>
    <div class="stats">
        <div class="counts">
            <span class="liked">‚úì Liked: <strong id="liked-count">0</strong></span>
            <span class="disliked">‚úó Disliked: <strong id="disliked-count">0</strong></span>
            <span class="pending">‚óã Pending: <strong id="pending-count">0</strong></span>
        </div>
        <div class="filters">
            <button class="filter-btn active" data-filter="all">All</button>
            <button class="filter-btn" data-filter="pending">Pending</button>
            <button class="filter-btn" data-filter="liked">Liked</button>
            <button class="filter-btn" data-filter="disliked">Disliked</button>
        </div>
        <div>
            <button class="reset-btn" onclick="resetAll()">Reset All</button>
            <button class="export-btn" onclick="exportLiked()">Export Liked ‚Üí</button>
        </div>
    </div>
    
    <h1>Sublobe Pattern Review</h1>
    <p class="instructions">
        Click images to enlarge. Use üëç/üëé buttons or keyboard shortcuts.
        <br>Selections are saved in your browser automatically.
    </p>
    
    <div class="gallery" id="gallery">
        <!-- Cards inserted by JavaScript -->
    </div>
    
    <div class="empty-state" id="empty-state" style="display:none;">
        <h2>No patterns found</h2>
        <p>Make sure this file is in the <code>sublobe-gen/</code> folder</p>
        <p>and you have patterns in <code>candidates/</code></p>
    </div>
    
    <div class="lightbox" id="lightbox" onclick="closeLightbox()">
        <span class="close">&times;</span>
        <img id="lightbox-img" src="" alt="Full size">
    </div>
    
    <div class="keyboard-hints">
        Keyboard: <kbd>L</kbd> like focused <kbd>D</kbd> dislike <kbd>‚Üí</kbd> next <kbd>‚Üê</kbd> prev <kbd>Esc</kbd> close
    </div>

    <script>
        // ========================================
        // CONFIGURATION
        // ========================================
        
        // Storage key for localStorage
        const STORAGE_KEY = 'sublobe-review-state';
        
        // ========================================
        // STATE
        // ========================================
        
        let state = {
            decisions: {},  // uuid -> 'liked' | 'disliked' | null
            currentFilter: 'all'
        };
        
        let candidates = [];  // Will be populated from filesystem scan
        let focusedIndex = 0;
        
        // ========================================
        // INITIALIZATION
        // ========================================
        
        function init() {
            loadState();
            scanCandidates();
            setupKeyboard();
            setupFilters();
        }
        
        function loadState() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    state = JSON.parse(saved);
                }
            } catch (e) {
                console.warn('Could not load state:', e);
            }
        }
        
        function saveState() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
            } catch (e) {
                console.warn('Could not save state:', e);
            }
        }
        
        // ========================================
        // SCANNING CANDIDATES
        // ========================================
        
        async function scanCandidates() {
            // Since we can't actually scan filesystem from browser,
            // we'll look for a generated manifest OR use the patterns
            // that are embedded/linked.
            
            // Try to fetch manifest first
            try {
                const response = await fetch('candidates/manifest.json');
                if (response.ok) {
                    candidates = await response.json();
                    renderGallery();
                    return;
                }
            } catch (e) {
                // No manifest, try to detect patterns
            }
            
            // Fallback: try common UUIDs or show instructions
            // In practice, you'll want to generate manifest.json
            showEmptyState();
        }
        
        function showEmptyState() {
            document.getElementById('empty-state').style.display = 'block';
            document.getElementById('gallery').innerHTML = `
                <div style="grid-column: 1/-1; text-align: center; padding: 40px;">
                    <h3>To use this reviewer:</h3>
                    <p>Run this command to generate the manifest:</p>
                    <pre style="background:#222; padding:15px; border-radius:8px; text-align:left; display:inline-block;">
python3 -c "
import json, os
from pathlib import Path

candidates = []
for d in Path('candidates').iterdir():
    if d.is_dir():
        meta_file = d / 'metadata.json'
        if meta_file.exists():
            with open(meta_file) as f:
                meta = json.load(f)
            candidates.append({
                'uuid': meta.get('uuid', d.name),
                'folder': d.name,
                'cells': meta.get('cells', {}).get('count', '?'),
                'method': meta.get('source', {}).get('method', '?'),
                'width': meta.get('dimensions', {}).get('width_mm', '?'),
                'height': meta.get('dimensions', {}).get('height_mm', '?')
            })

with open('candidates/manifest.json', 'w') as f:
    json.dump(candidates, f, indent=2)

print(f'Created manifest with {len(candidates)} candidates')
"</pre>
                    <p>Then refresh this page.</p>
                </div>
            `;
        }
        
        // ========================================
        // RENDERING
        // ========================================
        
        function renderGallery() {
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';
            
            candidates.forEach((c, index) => {
                const decision = state.decisions[c.uuid] || null;
                const card = document.createElement('div');
                card.className = 'card' + (decision ? ` ${decision}` : '');
                card.dataset.uuid = c.uuid;
                card.dataset.index = index;
                
                card.innerHTML = `
                    <img src="candidates/${c.folder}/render.png" 
                         alt="${c.uuid}"
                         onclick="openLightbox('candidates/${c.folder}/render.png')"
                         onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text x=%2250%%22 y=%2250%%22 text-anchor=%22middle%22 fill=%22%23666%22>No image</text></svg>'">
                    <div class="info">
                        <div class="uuid">${c.uuid}</div>
                        <div class="meta">${c.method} ¬∑ ${c.cells} cells ¬∑ ${c.width}√ó${c.height}mm</div>
                    </div>
                    <div class="actions">
                        <button class="like-btn ${decision === 'liked' ? 'active' : ''}" 
                                onclick="setDecision('${c.uuid}', 'liked')">
                            üëç Like
                        </button>
                        <button class="dislike-btn ${decision === 'disliked' ? 'active' : ''}"
                                onclick="setDecision('${c.uuid}', 'disliked')">
                            üëé Dislike
                        </button>
                    </div>
                `;
                
                gallery.appendChild(card);
            });
            
            updateCounts();
            applyFilter();
        }
        
        // ========================================
        // DECISIONS
        // ========================================
        
        function setDecision(uuid, decision) {
            const current = state.decisions[uuid];
            
            // Toggle off if clicking same decision
            if (current === decision) {
                state.decisions[uuid] = null;
            } else {
                state.decisions[uuid] = decision;
            }
            
            saveState();
            updateCardUI(uuid);
            updateCounts();
        }
        
        function updateCardUI(uuid) {
            const card = document.querySelector(`.card[data-uuid="${uuid}"]`);
            if (!card) return;
            
            const decision = state.decisions[uuid];
            card.classList.remove('liked', 'disliked');
            if (decision) card.classList.add(decision);
            
            const likeBtn = card.querySelector('.like-btn');
            const dislikeBtn = card.querySelector('.dislike-btn');
            
            likeBtn.classList.toggle('active', decision === 'liked');
            dislikeBtn.classList.toggle('active', decision === 'disliked');
            
            applyFilter();
        }
        
        function updateCounts() {
            let liked = 0, disliked = 0;
            
            candidates.forEach(c => {
                const d = state.decisions[c.uuid];
                if (d === 'liked') liked++;
                else if (d === 'disliked') disliked++;
            });
            
            const pending = candidates.length - liked - disliked;
            
            document.getElementById('liked-count').textContent = liked;
            document.getElementById('disliked-count').textContent = disliked;
            document.getElementById('pending-count').textContent = pending;
        }
        
        // ========================================
        // FILTERING
        // ========================================
        
        function setupFilters() {
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.currentFilter = btn.dataset.filter;
                    saveState();
                    applyFilter();
                });
            });
        }
        
        function applyFilter() {
            const filter = state.currentFilter;
            
            document.querySelectorAll('.card').forEach(card => {
                const uuid = card.dataset.uuid;
                const decision = state.decisions[uuid] || 'pending';
                
                let show = false;
                if (filter === 'all') show = true;
                else if (filter === 'pending') show = !state.decisions[uuid];
                else if (filter === 'liked') show = decision === 'liked';
                else if (filter === 'disliked') show = decision === 'disliked';
                
                card.classList.toggle('hidden', !show);
            });
        }
        
        // ========================================
        // LIGHTBOX
        // ========================================
        
        function openLightbox(src) {
            document.getElementById('lightbox-img').src = src;
            document.getElementById('lightbox').classList.add('active');
        }
        
        function closeLightbox() {
            document.getElementById('lightbox').classList.remove('active');
        }
        
        // ========================================
        // KEYBOARD NAVIGATION
        // ========================================
        
        function setupKeyboard() {
            document.addEventListener('keydown', (e) => {
                // Close lightbox on Escape
                if (e.key === 'Escape') {
                    closeLightbox();
                    return;
                }
                
                const visibleCards = Array.from(document.querySelectorAll('.card:not(.hidden)'));
                if (visibleCards.length === 0) return;
                
                // Clamp focus index
                focusedIndex = Math.max(0, Math.min(focusedIndex, visibleCards.length - 1));
                const focused = visibleCards[focusedIndex];
                if (!focused) return;
                
                const uuid = focused.dataset.uuid;
                
                switch (e.key.toLowerCase()) {
                    case 'l':
                        setDecision(uuid, 'liked');
                        break;
                    case 'd':
                        setDecision(uuid, 'disliked');
                        break;
                    case 'arrowright':
                    case 'j':
                        focusedIndex = Math.min(focusedIndex + 1, visibleCards.length - 1);
                        scrollToFocused();
                        break;
                    case 'arrowleft':
                    case 'k':
                        focusedIndex = Math.max(focusedIndex - 1, 0);
                        scrollToFocused();
                        break;
                    case 'enter':
                        const img = focused.querySelector('img');
                        if (img) openLightbox(img.src);
                        break;
                }
            });
        }
        
        function scrollToFocused() {
            const visibleCards = Array.from(document.querySelectorAll('.card:not(.hidden)'));
            const focused = visibleCards[focusedIndex];
            if (focused) {
                focused.scrollIntoView({ behavior: 'smooth', block: 'center' });
                // Visual feedback
                visibleCards.forEach(c => c.style.outline = 'none');
                focused.style.outline = '2px solid #4a9';
            }
        }
        
        // ========================================
        // EXPORT
        // ========================================
        
        function exportLiked() {
            const liked = candidates
                .filter(c => state.decisions[c.uuid] === 'liked')
                .map(c => c.folder);
            
            if (liked.length === 0) {
                alert('No patterns liked yet!');
                return;
            }
            
            // Create export text
            const text = liked.join('\n');
            
            // Download as file
            const blob = new Blob([text], { type: 'text/plain' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'liked_patterns.txt';
            a.click();
            
            // Also show copy command
            alert(`Downloaded liked_patterns.txt with ${liked.length} patterns.\n\nTo copy to selected/ folder, run:\n\ncat liked_patterns.txt | while read f; do cp -r "candidates/$f" selected/; done`);
        }
        
        function resetAll() {
            if (confirm('Reset all decisions? This cannot be undone.')) {
                state.decisions = {};
                saveState();
                renderGallery();
            }
        }
        
        // ========================================
        // START
        // ========================================
        
        init();
    </script>
</body>
</html>
